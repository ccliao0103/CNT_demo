<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å¥ˆç±³ç¢³ç®¡æ‰‹å‹¢äº’å‹•æ¨¡æ“¬</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; color: white; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 360px;
            background: rgba(40, 40, 40, 0.85); backdrop-filter: blur(8px);
            border-radius: 15px; z-index: 10; padding: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; gap: 8px;
        }
        .control-row { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
        select, input { background: #222; border: 1px solid #555; color: white; padding: 5px; border-radius: 5px; text-align: center; }
        label { font-size: 13px; color: #ccc; }
        
        /* éš±è—æ”å½±æ©Ÿ */
        .input_video { position: absolute !important; visibility: hidden !important; width: 1px; height: 1px; opacity: 0; }

        /* ç‹€æ…‹æç¤º (ä¿®æ”¹ 2: æ›´æ–°æç¤ºæ–‡å­—) */
        #gesture-hint {
            position: absolute; bottom: 20px; left: 0; width: 100%;
            text-align: center; font-size: 14px; color: #888; z-index: 5;
            text-shadow: 1px 1px 2px black;
        }

        /* (ä¿®æ”¹ 3: å·²ç§»é™¤ç‰¹æ•ˆå­—å¡çš„ CSS) */
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="control-row">
            <label>æ²æ³• Type</label>
            <select id="type-select" onchange="updateTypeUI()">
                <option value="armchair" selected>Armchair (n, n)</option>
                <option value="zigzag">Zigzag (n, 0)</option>
                <option value="chiral">Chiral (n, m)</option>
            </select>
        </div>
        <div class="control-row">
            <label>n:</label><input type="number" id="n-input" value="5" min="2" max="25" onchange="onParamChange()" style="width:40px">
            <label>m:</label><input type="number" id="m-input" value="5" min="0" max="25" onchange="onParamChange()" disabled style="width:40px">
        </div>
        <div class="control-row">
            <label>é•·åº¦ Len</label>
            <input type="range" id="len-slider" min="10" max="80" value="20" step="5" oninput="onParamChange()" style="flex:1">
        </div>
    </div>

    <div id="gesture-hint">âœŠæ¡æ‹³:ç¸®å° | ğŸ–ï¸å¼µé–‹:æ”¾å¤§</div>

    <div id="canvas-container"></div>
    <video id="input_video" class="input_video" playsinline></video>

<script>
    // --- è®Šæ•¸ ---
    let scene, camera, renderer, cntGroup;
    let atomMesh, bondMesh;
    
    // æ“ä½œè®Šæ•¸
    let currentRotationX = 0, currentRotationY = 0;
    let currentScale = 1;
    let lastHandX = null, lastHandY = null;

    const ACC = 1.42; 
    const MAX_ATOMS = 6000; 

    // --- Three.js åˆå§‹åŒ– ---
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(10, 10, 20);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x666666));

        cntGroup = new THREE.Group();
        scene.add(cntGroup);

        // --- è¦–è¦ºè¨­å®šï¼šçƒæ£æ¨¡å‹ ---
        
        // 1. åŸå­ï¼šå°çƒ
        const atomGeo = new THREE.SphereGeometry(0.35, 16, 16); 
        const atomMat = new THREE.MeshPhongMaterial({ color: 0x999999, shininess: 100 });
        atomMesh = new THREE.InstancedMesh(atomGeo, atomMat, MAX_ATOMS);
        cntGroup.add(atomMesh);

        // 2. éµçµï¼šç´°æ£ (ä¿®æ”¹ 6: ä¿®æ­£å¹¾ä½•ä¸­å¿ƒä»¥ç¢ºä¿é€£çºŒæ€§)
        const bondGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 8); 
        // bondGeo.translate(0, 0.5, 0); // <--- ã€é—œéµä¿®æ”¹ã€‘ç§»é™¤é€™è¡Œï¼Œè®“è»¸å¿ƒä¿æŒåœ¨ä¸­å¿ƒ
        bondGeo.rotateX(Math.PI / 2); // è½‰å‘è®“ Z è»¸ç‚ºé•·åº¦æ–¹å‘ï¼Œæ–¹ä¾¿ lookAt å°é½Š
        
        const bondMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
        bondMesh = new THREE.InstancedMesh(bondGeo, bondMat, MAX_ATOMS * 1.5);
        cntGroup.add(bondMesh);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- å¥ˆç±³ç¢³ç®¡ç”Ÿæˆ ---
    function generateCNT(n, m, lengthAngstrom) {
        const a = Math.sqrt(3) * ACC;
        const circumference = a * Math.sqrt(n*n + m*m + n*m);
        const diameter = circumference / Math.PI;
        
        const a1x = 1.5 * ACC, a1y = (Math.sqrt(3)/2) * ACC;
        const a2x = 1.5 * ACC, a2y = -(Math.sqrt(3)/2) * ACC;
        const Cx = n * a1x + m * a2x, Cy = n * a1y + m * a2y;
        const Clen = Math.sqrt(Cx*Cx + Cy*Cy);
        const ux = Cx / Clen, uy = Cy / Clen; 
        const vx = -uy, vy = ux; 

        const atoms = [];
        const dummy = new THREE.Object3D();
        let atomCount = 0;
        
        const iMax = Math.ceil((lengthAngstrom + circumference)/ACC) + 3;

        for (let i = -iMax; i < iMax; i++) {
            for (let j = -iMax; j < iMax; j++) {
                processAtom(i * a1x + j * a2x, i * a1y + j * a2y);
                processAtom(i * a1x + j * a2x + ACC, i * a1y + j * a2y);
            }
        }

        function processAtom(x, y) {
            const u = x * ux + y * uy; 
            const v = x * vx + y * vy; 

            if (v >= 0 && v < lengthAngstrom) {
                if (u > -0.01 && u < circumference - 0.01) {
                    const theta = (u / circumference) * Math.PI * 2;
                    const R = diameter / 2;
                    const x3d = v - lengthAngstrom/2; 
                    const y3d = R * Math.cos(theta);
                    const z3d = R * Math.sin(theta);

                    atoms.push({ x: x3d, y: y3d, z: z3d });

                    if (atomCount < MAX_ATOMS) {
                        dummy.position.set(x3d, y3d, z3d);
                        dummy.scale.set(1, 1, 1);
                        dummy.rotation.set(0, 0, 0);
                        dummy.updateMatrix();
                        atomMesh.setMatrixAt(atomCount, dummy.matrix);
                        atomCount++;
                    }
                }
            }
        }
        atomMesh.count = atomCount;
        atomMesh.instanceMatrix.needsUpdate = true;

        // ç”Ÿæˆéµçµ
        let bondCount = 0;
        const bondLimitSq = 1.9 * 1.9; 

        for (let i = 0; i < atoms.length; i++) {
            for (let j = i + 1; j < atoms.length; j++) {
                const dx = atoms[i].x - atoms[j].x;
                const dy = atoms[i].y - atoms[j].y;
                const dz = atoms[i].z - atoms[j].z;
                const distSq = dx*dx + dy*dy + dz*dz;

                if (distSq < bondLimitSq) {
                    if (bondCount < MAX_ATOMS * 1.5) {
                        const dist = Math.sqrt(distSq);
                        // è¨ˆç®—å…©é»ä¸­é»
                        const midX = (atoms[i].x + atoms[j].x) / 2;
                        const midY = (atoms[i].y + atoms[j].y) / 2;
                        const midZ = (atoms[i].z + atoms[j].z) / 2;

                        // å°‡åœ“æŸ±(è»¸å¿ƒåœ¨ä¸­å¿ƒ)æ”¾ç½®æ–¼ä¸­é»
                        dummy.position.set(midX, midY, midZ);
                        // å°‡ Z è»¸æŒ‡å‘ç›®æ¨™é» (å› ç‚ºæˆ‘å€‘ä¸Šé¢ rotateX(PI/2) äº†)
                        dummy.lookAt(atoms[j].x, atoms[j].y, atoms[j].z);
                        // Z è»¸ç¸®æ”¾è‡³å…©é»è·é›¢ï¼Œé”åˆ°å®Œç¾é€£æ¥
                        dummy.scale.set(1, 1, dist);
                        dummy.updateMatrix();
                        
                        bondMesh.setMatrixAt(bondCount, dummy.matrix);
                        bondCount++;
                    }
                }
            }
        }
        bondMesh.count = bondCount;
        bondMesh.instanceMatrix.needsUpdate = true;
    }

    // --- MediaPipe æ‰‹å‹¢é‚è¼¯ ---
    // (ä¿®æ”¹ 7: ç§»é™¤ msgDiv è®Šæ•¸)
    
    function onResults(results) {
        // (ä¿®æ”¹ 8: ç§»é™¤ isVictory è®Šæ•¸)

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const handCenter = landmarks[9];

            const dIndex = dist(indexTip, wrist);
            const dMiddle = dist(middleTip, wrist);
            const dRing = dist(ringTip, wrist);
            const dPinky = dist(pinkyTip, wrist);

            // --- æ‰‹å‹¢åˆ¤å®š ---
            const isFist = (dIndex < 0.25 && dMiddle < 0.25 && dRing < 0.25 && dPinky < 0.25);
            const isOpen = (dIndex > 0.3 && dMiddle > 0.3 && dRing > 0.3 && dPinky > 0.3);
            // (ä¿®æ”¹ 9: ç§»é™¤å‹åˆ©æ‰‹å‹¢åˆ¤å®š)

            // --- è§¸ç™¼åŠŸèƒ½ (ä¿®æ”¹ 10: ç§»é™¤å­—å¡è§¸ç™¼é‚è¼¯) ---
            
            // ç¸®æ”¾é‚è¼¯
            if (isFist) {
                currentScale -= 0.03; // âœŠ ç¸®å°
            } else if (isOpen) {
                currentScale += 0.03; // ğŸ–ï¸ æ”¾å¤§
            }
            currentScale = Math.max(0.2, Math.min(currentScale, 6.0));

            // æ—‹è½‰é‚è¼¯
            if (lastHandX !== null && lastHandY !== null) {
                const deltaX = handCenter.x - lastHandX;
                const deltaY = handCenter.y - lastHandY;
                const sensitivity = 5.0;
                currentRotationY += deltaX * sensitivity;
                currentRotationX += deltaY * sensitivity;
            }

            lastHandX = handCenter.x;
            lastHandY = handCenter.y;

        } else {
            lastHandX = null;
            // (ä¿®æ”¹ 11: ç§»é™¤ hide msgDiv é‚è¼¯)
        }
    }
    
    function dist(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    // --- UI é€£å‹• (ç¶­æŒä¸è®Š) ---
    function updateTypeUI() {
        const type = document.getElementById('type-select').value;
        const nInput = document.getElementById('n-input');
        const mInput = document.getElementById('m-input');
        if (type === 'armchair') { mInput.value = nInput.value; mInput.disabled = true; }
        else if (type === 'zigzag') { mInput.value = 0; mInput.disabled = true; }
        else { mInput.disabled = false; }
        onParamChange();
    }

    function onParamChange() {
        const type = document.getElementById('type-select').value;
        let n = parseInt(document.getElementById('n-input').value);
        let m = parseInt(document.getElementById('m-input').value);
        const len = parseInt(document.getElementById('len-slider').value);
        if (type === 'armchair') { m = n; document.getElementById('m-input').value = n; }
        else if (type === 'zigzag') { m = 0; }
        generateCNT(n, m, len);
    }

    // --- å•Ÿå‹• ---
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(document.getElementById('input_video'), {
        onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
        width: 640, height: 480
    });
    cameraUtils.start();

    initThree();
    updateTypeUI();

    function animate() {
        requestAnimationFrame(animate);
        if (cntGroup) {
            cntGroup.rotation.y += (currentRotationY - cntGroup.rotation.y) * 0.1;
            cntGroup.rotation.x += (currentRotationX - cntGroup.rotation.x) * 0.1;
            const s = cntGroup.scale.x;
            cntGroup.scale.set(s + (currentScale - s) * 0.1, s + (currentScale - s) * 0.1, s + (currentScale - s) * 0.1);
        }
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
